# inside-JS

### 자바 스크립트의 핵심 개념
1. 객체: null과 undefined를 제외한 모든것을 객체로 다룰 수 있다.
2. 함수: 자바스크립트에서는 함수도 객체로 취급한다.
3. 프로토타입: 모든 객체느 숨겨진 링크인 프로토타입을 갖는다. 이 프로토타입을 활용해 상속을 구현한다.
4. 실행 컨텍스트와 클로저: 실행 컨텍스트는 자신만의 유효범위(scope)을 갖는데, 이 과정에서 클로저를 구현할 수 있다.

### 자바스크립트의 타입과 관련된 특징(Object.js)
* typeof 연산자 : 피연산자의 타입을 리턴
* 자바스크립트에서는 모드 숫자를 실수로 처리함. 따라서, 정수부분만을 원할 경우 Math.floor(num)를 사용하면 됨.
* 자바스크립트에서는 한번 생성된 문자열은 읽기만 가능하고 수정은 불가능.
* null과 undefined는 '값이 비어있음'을 나타냄.
* undefined는 타입이자 값이며, null을 typeof 연산으로 보면 Object로 나온다. 따라서 null타입의 변수인지를 확인하기 위해서는 일치 연산자(===)를 사용해야 함.
* 자바스크립트의 객체 생성방법은 다른 언어들과 다르게 클래스라는 개념이 없고, 객체 리터럴이나 생성자 함수 등 별도의 생성방식이 존재한다.
* 자바스크립트에서는 존재하지 않는 프로퍼티에 접근할 경우 undefined값이 출력된다.


### 객체를 생성하는 3가지 방법(Object.js, ForInObject.js)
1. 기본 제공 Object() 객체 생성자 함수 이용
2. 객체 리터럴을 사용
3. 생성자 함수 이용

### 객체 프로퍼티 읽기/쓰기/갱신(AccessProperty.js)
* 객체의 프로퍼티에 접근하려면 대괄호([])나 마침표(.)를 사용하면 된다.
  - 대괄호 표기법인 경우 접근하려는 프로퍼티 명을 문자열로 표기해야 한다. ex) foo['name']
  - 대괄호 표기법만을 이용해야 하는 경우가 있다.
    + 접근하려는 프로퍼티가 표현식이거나 예약어일 경우이다. 접근하려는 프로퍼티가 'full-name'일 경우 '-'연산자가 있는 표현식이므로 대관호 표기법만을 이용해서 접근해야 한다.
> 자바스크립트 객체의 프로퍼티에 값을 할당할 때, 프로퍼티가 이미 있을 경우는 해당 프로퍼티의 값이 갱신되지만, 객체에 해당 프로퍼티가 없는 경우에는 새로운 프로퍼티가 생성된 후 값이 할당된다.

### 객체 프로퍼티 삭제(DeleteProperty.js)
* delete 연산자를 이용하면 객체의 프로퍼티를 삭제할 수 있다.
* 그러나 delete 연산자로 객체 자체를 삭제하지는 못한다.

### 참조 타입의 특성(ReferenceType.js)
* 자바스크립트에서는 기본타입인 숫자, 문자열, 불린값, null, undefined를 제외한 모든 값은 객체다.
* 배열이나 함수 역시 객체로 취급된다.
* 이러한 객체들을 참조타입이라고 부른다.


### 객체비교(CompareObject.js)
* 동등연산자(==)은 두 객체를 비교할 때 객체의 프로퍼티값이 아닌 참조값을 비교한다는 점을 주의해야 한다.

### 참조에 의한 함수 호출 방식 Call By Reference(CallByReference.js)
* 기본타입의 경우 값에 의한 호출 Call By Value 방식으로 동작한다.
  - 즉, 함수를 호출할 때 인자로 기본타입을 넘길 경우, 호출된 함수의 매개변수로 '복사된 값'이 전달된다.
  - 때문에 함수 내부에서 매개변수를 이용해 값을 변경해도 실제로 호출한 변수의 값이 변경되지는 않는다.
* 객체와 같은 참조타입의 경우 함수를 호출할 때 참조에 의한 호출 Call By Refernece 방식으로 동작한다.
  - 즉, 함수를 호출할 때 인자로 참조타임을 넘길 경우, 인자로 넘긴 객체의 참조값을 매개변수도 같이 참조하게 된다. 
  - 때문에 함수 내부에서 참조값을 이용해서 인자로 넘긴 실제 객체의 값을 변경할 수 있다.

### 프로토타입(Prototype.js)
* 자바스크립트의 모든 객체는 자신의 부모 역할을 하는 객체와 연결되어 있다.
* 이러한 부모객체를 프로토타입 객체(프로토타입)라고 부른다.
* ECMAScript 명세서에는 자바스크립트의 모든 객체는 자신의 프로토타입을 가리키는 [[Prototype]]라는 숨겨진 프로토타입을 가진다고 설명하고 있다.
* 크롬브라우저에서는 [[Prototype]] 대신 __proto__라고 표기한다.
* 객체를 생성할 때 결졍되는 프로토타입 객체는 임의로 다른 객체로 변경하는 것도 가능하다. 즉, 부모 객체를 동적으로 변경할 수 있다는 뜻이다.(프로토타입 체이닝 부분에서 자세히 다룸)

### 배열(ArrayLiteral.js)
* 자바스크립트의 배열은 크기를 지정하지 않아도 되고, 어느 위치에 특정한 타입의 데이터를 저장하더라도 에러가 발생하지 않는다.
* 객체가 동적으로 프로퍼티를 추가할 수 있듯이, 배열도 동적으로 배열 원소를 추가 할 수 있다.

### 배열의 길이(ArrayLength.js)
* 모든 배열은 length 프로퍼티를 가지고 있다.
* length 프로퍼티는 배열의 원소의 개수를 나타내지만, 실제로 배열에 존재하는 원소의 개수와 일치하는 것은 아니다.
* length 프로퍼티는 배열 내에 가장 큰 인덱스에 +1을 한 값이다.
* length 프로퍼티는 코드를 통해 명시적으로 값을 변경할 수도 있다.

### 배열의 표준 메서드(ArrayStandardMethod.js)
* 배열 메서드는 length 프로퍼티를 기반으로 동작하고 있다.
* push(): 인수로 넘어온 항목을 배열의 끝(length 프로퍼티)에 추가하는 메서드

### 배열과 객체(ArrayAndObject.js)
* 배열과 객체는 모두 object 타입이다.
* 당연한 말이겠지만 객체에는 length 프로퍼티가 존재하지 않는다.
* 배열의 프로토타입은 Array.prototype이므로 배열 표준 메서드를 사용할 수 있다.
* 객체의 프로토타입은 Object.prototype이므로 배열 표준 메서드를 사용할 수 없다.

### 배열의 프로퍼티 동적 생성(ArrayDynamicBinding.js)
* 자바스크립트의 배열은 객체이므로 인덱스가 숫자인 배열 원소 이외에도 객체처럼 동적으로 프로퍼티를 추가할 수 있다.
* 배열의 length 프로퍼티는 배열 원소의 가장 큰 인덱스가 변했을 경우에만 변경된다.
* 배열에 동적 프로퍼티가 추가된 경우에는 인덱스가 변경되지 않는다.

### 배열의 프로퍼티 열거(ArraysEnumeration.js)
* 객체는 for in 문으로 프로퍼티를 열거한다. 배열도 객체이므로 for in 문을 이용해 프로퍼티를 열거할 수 있다.
* for in 문으로 배열의 프로퍼티를 열거하는 경우 불필요한 프로퍼티가 출력될 수 있으므로 되도록 for 문을 쓰는게 좋다.

### 배열 요소 삭제(DeleteArray.js)
* 배열 요소나 프로퍼티를 삭제할 때 delete 연산자를 사용할 수 있다.
* delete로 배열의 요소를 삭제하면 기존 값 대신 undefined를 사용할 뿐 length의 값은 변하지 않는다.
* 따라서 배열의 요소들을 완전히 삭제할 경우 splice() 배열 메서드를 사용한다.
  - splice(start, deleteCount, item...)
    + start: 배열에서의 시작 위치
    + deleteCount: start에서 지정한 시작 위치부터 삭제할 요소의 수
    + item: 삭제할 위치에 추가할 요소

### Array() 생성자 함수(ArrayConstruct.js)
* 생성자 함수로 객체를 생성할 때는 반드시 new 키워드를 같이 써야 한다.
* Array() 생성자 함수는 호출할 때의 인자 개수에 따라 동자깅 다르므로 주의해야 한다.
  - 호출할 때 인자가 1개이고, 숫자일 경우: 호출된 인자를 length로 갖는 빈 배열 생성
  - 그 외의 경우: 호출된 인자를 요소로 갖는 배열 생성

### 유사 배열 객체(ArrayLikeObjects.js)
* 자바스크립트에서는 length 프로퍼티를 가진 객체를 '유사 배열 객체'라고 부른다.
* 유사 배열 객체의 가장 큰 특징은 객체임에도 불구하고, 자바스크립트의 표준 배열 메서드를 사용하는게 가능하다는 점이다.

### 기본 타입과 표준 메서드(PrimitiveTypeAndStandardMethod.js)
* 기본 타입의 값들에 대해 객체 형태로 메서드를 호출할 경우, 이 기본값들은 메서드 처리 순간에 객체로 변환된 다음 각 타입별 표준 메서드를 호출하게 된다. 그리고 메서드 호출이 끝나면 다시 기본값으로 복귀하게 된다.

### +연산자
* +연산자는 숫자의 더하기 연산과 문자열 연결 연산을 수행한다.

### typeof 연산자
* typeof 연산자는 피연산자의 타입을 문자열 형태로 리턴한다. 
* null과 배열이 'object'라는 것과 함수는 'function'이라는 점에 주의해야 한다.
  - 숫자: 'number'
  - 문자열: 'string'
  - 불린값: 'boolean'
  - null: 'object'
  - undefined: 'undefined'
  - 객체: 'object'
  - 배열: 'object'
  - 함수: 'function'

### ==(동등) 연산자와 ===(일치) 연산자
* 동등 연산자(==)는 피연산자의 타입이 다를 경우에 타입 변환을 거친 다음 비교한다.
* 일치 연산자(===)는 피연산자의 타입이 다를경우에 타입을 변경하지 않고 비교한다.
  - 1 == '1'은 true를 리턴
  - 1 === '1'은 false를 리턴

### !!연산자
* !!연산자의 역할은 피연산자를 불린값으로 변환하는 것이다.
  - console.log(!!0) // false
  - console.log(!!1) // true
  - console.log(!!'string') // true
  - console.log(!!'') // false
  - console.log(!!true) // true
  - console.log(!!false) // false
  - console.log(!!null) // false
  - console.log(!!undefined) // false
  - console.log(!!{}) // true
  - console.log(!![1,2,3]) // true
* 객체는 값이 비어있는 빈 객체라도 true로 변환되는 것을 주의해야 한다.

### 함수와 프로토타입 체이닝
* 자바스크립트에서 가장 중요한 개념 1순위는 '함수'다.
* 자바스크립트의 함수는 모듈화 처리나 클로저, 객체 생성 등 자바스크립트의 근간이 되는 많은 기능을 제공한다.

### 함수 정의
* 자바스크립트에서 함수를 생성하는 방법은 3가지가 있다.
  - 함수 선언문(functon statement)
  - 함수 표현식(function expression)
  - Function() 생성자 함수
* 각각의 방식에 따라 함수 동장에 미묘한 차이가 있다.

### 함수 리터럴
```
function add(x, y) {
  return x + y
}
```
* 함수명을 쓰지 않으면 익명함수로 정의된다.
* 매개변수의 타입을 따로 적어주지 않는다.

### 함수 선언문
* 선언문 방식은 리터럴 형식과 같지만 반드시 함수명이 정의 되어야 한다는 점이 다르다.

### 함수 표현식(FunctionExpression.js)
* 자바스크립트에서는 함수도 하나의 값처럼 취급된다. 따라서 함수를 변수에 할당하는 것이 가능하다.
* 함수 표현식은 선언문과 문법이 거의 유사하지만 보통 함수의 이름을 사용하지 않는다.

### Function() 생성자 함수를 통한 함수 생성
* 자바스크립트의 함수도 Function()이라는 기본 내장 생성자 함수로부터 생성된 객체라고 볼 수 있다.
* Function() 생성자 함수를 사용한 함수 생성 방법은 이제 더 이상 자주 사용되지 않는다.
```
let add = new Function('x', 'y', 'return x + y')
console.log(add(3, 4)) // 7
```

### 함수 호이스팅(FunctionHoisting.js)
* 더글러스 크락포드(자바스크립트를 만든 개발자)는 함수 호이스팅 때문에 '함수 표현식'만 사용할 것을 권하고 있다.
* '함수 선언문' 형태로 정의한 함수의 유효범위는 코드의 맨 처음부터 시작하는 것을 함수 호이스팅이라고 부른다.
* '함수 표현식' 형태로 정의한 함수는 호이스팅이 일어나지 않는다.
* 이러한 함수 호이스팅이 발생하는 원인은 자바스크립트의 변수생성과 초기화의 작업이 분리되서 진행되기 때문이다.

### 함수도 객체(FunctionIsObject.js)
* 자바스크립트에서는 함수도 객체다. 함수의 기능인 코드 실행뿐 아니라 함수 자체가 프로퍼티를 가질 수 있다.
* 자바스크립트에서는 함수도 일반 객체처럼 취급될 수 있다. 따라서, 다음과 같은 동작이 가능하다.
  - 리터럴에 의해 생성
  - 변수나 배열의 요소, 객체의 프로퍼티 등에 할당 가능
  - 함수의 인자로 전달 가능
  - 함수의 리턴값으로 리턴 가능
  - 동적으로 프로퍼티 생성 및 할당 가능
* 이러한 특징 때문에 자바스크립트에서는 함수를 일급(first class)객체라고 부른다.

### 함수 객체의 기본 프로퍼티(FuncBasicProperty.js)
* 함수 객체만의 표준 프로퍼티가 정의되어 있다.
* ECMAScript5 명세서에는 모든 함수가 length와 prototype프로퍼티를 가져야 한다고 기술하고 있다.
* name, caller, arguments, __proto__ 프로퍼티 간단하게 살펴보기
  + name: 함수의 이름
  + caller: 자신을 호출한 함수
  + arguments: 함수를 호출할 때 전달된 인자값
  + __proto__: [[Prototype]]이라는 내부 프로퍼티
    - Function.prototype 객체는 모든 함수들의 부모 역할을 하는 프로토타입 객체
* length 프로퍼티
  + 함수 객체의 length는 함수를 작성할 때 정의한 인자 갯수를 나타낸다.
* prototype 프로퍼티
  + 함수 객체의 prototype 프로퍼티는 모든 객체의 부모를 나타내는 내부 프로퍼티인 [[Prototype]]과 다르다.
    - [[Prototype]]: 객체 입장에서 자신의 부모 역할을 하는 프로토타입 객체를 가리킴.
    - 함수의 prototype: 함수가 생성자로 사용될 때, 이 함수를 통해 생성된 객체의 부모 역할을 하는 프로토타입 객체를 가리킴.
  + protytype 프로퍼티는 함수가 생성될 때 만들어지며 constructor 프로퍼티 하나만 있는 객체를 가리킨다.
    - constructor 프로퍼티는 자신과 연결되 함수를 가리킨다. 즉, 서로가 서로를 참조하게 된다.
* 함수 객체와 프로토타입 객체는 서로 밀접하게 연결되어 있다.

### 함수의 다양한 형태
* 콜백 함수
  + 코드를 통해 명시적으로 호출하는 함수가 아니라 어떤 이벤트가 발생했거나 특정 시점에 도달했을 때 시스템에서 호출되는 함수를 말한다.
  + 또한, 특정 함수의 인자로 넘겨서, 코드 내부에서 호출되는 함수 또한 콜백함수가 될 수 있다.
  + 대표적인 콜백함수로는 자바스크립트에서의 이벤트 핸들러가 있다.
    - 웹 페이지가 로드되거나 키보드가 입력되는 등의 DOM 이벤트가 발생할 경우, 브라우저는 정의된 DOM 이벤트에 해당하는 이벤트 핸들러를 실행시킨다. 만약 이벤트 핸들러에 콜백 함수가 등록되어있다면 콜백함수는 이벤트가 발생할 때마다 브라우저에 의해 실행되게 된다.
* 즉시 실행 함수
  + 함수를 정의함과 동시에 바로 실행하는 함수를 말한다.
  + 즉시 실행 함수도 익명 함수를 응용한 형태이다.
    ```
      (function (name) {
        console.log('This is the immediate function ->' + name)
      })('hello')
      // This is the immediate function -> hello
    ```
  + 즉시 실행 함수의 경우, 같은 함수를 다시 호출할 수 없다는 특징을 가진다.
  + 따라서 최초 한 번의 실행만을 필요로 하는 초기화 코드 부분 등에 사용할 수 있다.
* 내부 함수(InnerFunction.js)
  + 함수 내부에 정의된 함수를 내부 함수라고 부른다.
  + 내부 함수는 클로저를 생성하거나 부모 함수 코드에서 외부의 접근을 막고 독립적인 헬퍼 함수를 구현하는 용도 등으로 사용한다.
  + 내부 함수에서는 자신을 둘러싼 부모 함수의 변수에 접근이 가능하다. (스코프체이닝 때문에 가능)
  + 내부 함수는 일반적으로 자신이 정의된 부모 함수 내부에서만 호출이 가능하다.
  + 다만, 부모 함수에서 내부 함수를 리턴하며, 부모 함수 밖에서도 내부 함수를 호출하는 것이 가능하다.(InnerFunction2.js)
* 함수를 리턴하는 함수(FuncReturnFunc.js)
  + 자바스크립트에서는 함수도 일급 객체이므로 일반 값처럼 함수 자체를 리턴할 수도 있다.
  + 이러한 특징으로 함수를 호출함과 동시에 다른 함수로 바꾸거나, 자기 자신을 재정의 하는 함수를 구현할 수 있다.

### 함수 호출과 this(/FunctionCallAndThis)
* arguments 객체(Arguments.js)
  + 함수를 호출할 때, 함수 형식에 맞춰 인자를 넘기지 않더라도 에러가 발생하지 않는다.
* 호출 패턴과 this 바인딩
  + 자바스크립트에서는 함수를 호출할 때, 인자 외에도 arguments객체와 this를 함께 전달한다.
  + this는 함수가 호출되는 방식(호출 패턴)에 따라 다른 객체를 참조(this 바인딩)한다.
* 객체의 메서드 호출할 때 this 바인딩(ThisBinding.js)
  + 객체의 프로퍼티가 함수일 경우, 이 함수를 메서드라고 부른다.
  + 이러한 메서드를 호출할 때, 메서드 내부 코드에서 사용된 this는 '해당 메서드를 호출한 객체'로 바인딩된다.
* 함수를 호출할 때 this 바인딩
  + 자바스크립트에서 함수를 호출하면, 해당 함수 내부 코드에서 사용된 this는 전역 객체에 바인딩된다.
  + 브라우저에서 자바스크립트를 실행하는 경우 전역 객체는 window 객체가 된다.
  + 자바스크립트의 모든 전역 변수는 실제로는 이러한 전역 객체의 프로퍼티들이다.
* 내부 함수를 호출한 경우의 this(InnerFuncThis.js)
  + 내부 함수의 호출패턴을 정의해 놓지 않으면 내부함수의 this는 전역객체(window)에 바인딩된다.
  + 이렇게 내부함수가 this를 참조하는 자바스크립트의 한계를 극복하려면 '부모함수의 this'를 내부함수가 접근 가능한 '다른 변수에 저장'하는 방법이 사용된다.
  + 컨벤션에 따라 this를 저장하는 변수의 이름은 that이라고 짓는다.
  + 자바스크립트에서는 이와 같은 this 바인딩의 한계를 극복하려고 this바인딩을 명시적으로 할 수 있는 call과 apply 메서드를 제공한다.
* 생성자 함수를 호출할 때 this 바인딩
  + 자바스크립트의 생성자 함수는 말 그대로 자바스크립트의 객체를 생성하는 역할을 한다.
  + 다만 형식이 정해져 있지 않고, 기존 함수에 new 연산자를 붙여 호출하면 해당 함수는 생성자 함수로 동작한다.
  + 자바스크립트 스타일 가이드에서는 특정 함수라 생성자 함수로 정의되어 있음을 알리려고 함수의 이름의 첫 문자를 대문자로 쓰기를 권하고 있다.
  + 생성자 함수 코드 내부에서 this는 메서드와 함수 호출방식에서의 this 바인딩과는 다르게 동작한다.
    - 생성자 함수가 동작하는 방식(ConstructorFunction.js)
    1. 빈 객체 생성 및 this 바인딩
    생성자 함수 코드가 실행되기 전 빈 객체가 생성된다. 이 객체는 this로 바인딩 되며 생성자 함수의 내부코드에서 사용되는 this는 이 빈 객체를 가리킨다.
    but, 이 빈 객체는 엄밀히 말하면 빈 객체는 아니다. 모든 객체는 자신의 부모인 프로토타입과 연결되어 있기 때문이다.
    이렇게 생성자 함수가 만드는 객체는 자신을 만든 생성자 함수의 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다.(이건 자바스크립트의 규칙!!)
    2. this를 통한 프로퍼티 생성
    이후에는 함수 코드 내부에서 this를 사용해서 앞에서 생성된 빈 객체에 동적으로 프로퍼티나 메서드를 생성할 수 있다.
    3. 생성된 객체 리턴
    리턴문이 동작하는 방식은 경우에 따라 다르므로 조심해야 한다. 우선, 가장 일반적인 경우로 특별하게 리턴문이 없는경우 this로 바인딩 된 새로운 객체가 리턴된다. 명시적으로 this를 리턴해도 결과가 같다.
    (주의 - 생성자 함수가 아닌 일반 함수를 호출할 때 리턴값이 명시되어 있지 않으면 undefined가 리턴된다.)
    리턴값이 새로 생성한 객체(this)가 아닌 다른 객체를 반환하는 경우 생성자 함수를 호출했다고 하더라도 this가 아닌 해당 객체가 리턴된다.

### 객체 리터럴 방식과 생성자 함수 방식의 차이점(ConstructorFunction.js)
* 프로토타입 객체가 다르다. 
  + 객체 리터럴의 경우 자신의 프로토타입 객체는 Object(Object.prototype)다. 
  + 생성자 방식의 경우는 Person(Person.prototype)이다
* 이런 차이가 발생하는 이유는 자바스크립트 객체 생성 규칙 때문이다. 자바스크립트 객체는 자신을 생성한 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다.

### 생성자 함수를 new키워드 없이 호출할 경우(ConstructorFunction.js)
* 자바스크립트에서는 일반함수와 생성자 함수 사이에 큰 차이가 없다. new를 붙여서 함수를 호출하면 생성자 함수로 동작하는 것이다.
* 따라서 객체 생성을 목적으로 작성한 생성자 함수를 new없이 호출하거나 일반 함수를 new를 붙여서 호출할 경우 코드에서 오류가 발생할 수 있다.
* 그 이유는 일반 함수 호출과 생성자 함수 호출 시의 this 바인딩 방식이 다르기 때문이다.
* 일반 함수 호출의 경우 this가 window(전역 객체)에 바인딩되는 반면, 생성자 함수 호출의 경우 this는 새로 생성되는 빈 객체에 바인딩 되기 때문이다.

### call과 apply메서드를 이용한 명시적인 this 바인딩(ApplyWithThis.js)
* 자바스크립트는 this를 특정 객체에 명시적으로 바인딩시키는 방법을 제공한다.
* 이 명시적 바인딩을 가능하게 하는 메서드가 바로 call()과 apply()이다.
* call()과 apply()는 모든 함수의 부모객체인 Function.prototype객체의 메서드이므로 아래와 같은 형식으로 호출하는 것이 가능하다.
  ```
    function.apply(thisArg, argArray)
  ```
  + call() 메서드는 apply()메서드와는 기능이 같고 단지 넘겨받는 인자의 형식만 다르다.
  + 중요한 것은 apply() 메서드도 this를 특정 객체에 바인딩 할 뿐 결국 본질적인 기능은 함수 호출이라는 것이다.
  + Person()이라는 함수가 있고, Person.apply() 이렇게 호출한다면 이것의 기본적인 기능은 Person()함수를 호출하는 것이다.
* apply() 메서드에 대해 살펴보자.
  + 첫번째 인자 thisArg는 apply()를 호출한 함수 내부에서 사용한 this에 바인딩 할 객체를 가리킨다. 즉, 첫번째 인자로 넘긴 객체가 this로 명시적으로 바인딩되는 것이다.
  + 두번째 argArray 인자는 함수를 호출할 때 넘길 인자들의 배열을 가리킨다.
  + 정리하면 두번째 인자인 argArray 배열을 자신을 호출한 함수의 인자로 사용하되, 이 함수 내부에서 사용된 this는 첫번째 인자인 thisArg 객체로 바인딩해서 함수를 호출하는 기능을 하는 것이다.
* call() 메서드를 살펴보면 apply()의 두번째 인자에서 배열로 넘긴 것을 각각의 인자로 넘긴다.
  ```
    function.call(thisArg, arg1, arg2, arg3)
  ```

### call()과 apply()의 대표적인 용도는 arguments 객체와 같은 유사 배열 메서드를 사용하는 경우이다.(ArgumentsObjectWithApply.js)
* arguments 객체는 실제 배열이 아니므로 pop(), shift() 같은 표준 배열 메서드를 사용할 수 없다. 그러나 apply()를 이용하면 가능하다.

### 함수리턴(FunctionReturn.js)
* 자바스크립트 함수는 항상 리턴값을 반환한다. 특히, return을 사용하지 않더라도 다음의 규칙으로 항상 리턴값을 전달하게 된다.
 + 일반 함수나 메서드는 리턴값을 지정하지 않을 경우, undefined 값이 리턴된다.(FunctionReturn.js/noReturnFunc)
 + 생성자 함수에서 리턴값을 지정하지 않을 경우 생성된 객체가 리턴된다.
  - 생성자 함수에서 별도의 리턴값을 지정하지 않을 경우 this로 바인딩 된 새로 생성된 객체가 리턴된다.
  - 따라서 생성자 함수에서는 일반적으로 리턴값을 지정하지 않는다.
  - 생성자 함수에서 리턴값으로 객체가 아닌 숫자, 문자열, 불린을 넘기면 넘겨진 return값은 무시되고 this로 바인딩 된 객체가 리턴된다.

## 프로토타입 체이닝

### 프로토타입 체이닝(PrototypeAndPrototype.js)
* 자바스크립트에서 OOP 상속에 근간이 되는 프로토타입과 프로토타입 체이닝의 기본 개념
* 자바스크립트의 모든 객체는 자신의 부모인 프로토타입 객체를 가리키는 참조 링크 형태의 숨겨진 프로퍼티가 있다.
* ECMAScript에서는 이러한 링크를 '암묵적 프로토타입 링크'라고 부르며 이러한 링크는 모든 객체의 [[Prototype]] 프로퍼티에 저장된다. 그리고 이 책에서는 이러한 링크를 [[Prototype]]링크라고 명명한다.
* 주의해야 할 점은 prototype 프로퍼티에서 설명했던 함수 객체의 prototype 프로퍼티와 객체의 숨은 프로퍼티인 [[Prototype]] 링크를 구분해야한다는 점이다.
  + 이 둘의 차이점을 이해하려면 자바스크립트의 객체 생성 규칙을 알아야 한다.
  + 자바스크립트에서 모든 객체는 자신을 생성한 생성자 함수의 prototype 프로퍼티가 가리키는 프로토타입 객체를 자신의 부모 객체로 설정하는 [[Prototype]]링크로 연결한다.

### 객체 리터럴 방식으로/생성자 함수로 생성된 객체의 프로토타입 체이닝(ObjectLiteralPrototyoeChaining.js)
* 자바스크립트에서는 객체가 자신의 프로퍼티뿐만이 아니라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티 또한 마치 자신의 것처럼 접근하는게 가능하다. 이것을 가능하게 하는것이 프로토타입 체이닝이다.
* 자바스크립트에서 모든 객체는 자신을 생성한 생성자 함수의 protytype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체(부모 객체)로 취급한다.

### 프로토타입 체이닝의 종점
* 자바스크립트에서 Object.prototype 객체는 프로토타입 체이닝의 종점이다.

### 기본 데이터 타입 확장
* 자바스크립트의 숫자, 문자열, 배열 등에서 사용되는 표준 메서드들의 경우, 이들의 프로토타입인 Number.protytype, String.protytype, Array.protytype 등에 정의되어 있다.
* 기본 데이터 타입의 내장 프로토타입 객체 또한 Object.protytype를 자신의 프로토타입으로 가지고 있다.
* ECMAScript 명세서를 보면 자바스크립트의 각 네이티브 객체별로 공통으로 제공해야 하는 메서드들을 각각의 프로토타입 객체 내에 메서드로 정의해야 한다고 기술하고 있다.
* 자바스크립트는 Object.protytype나 String.protytype 등과 같이 이러한 표준 빌트인 프로토타입 객체에도 사용자가 직접 정의한 메서드들을 추가하는 것을 허용한다. 
* 다음 예제처럼 String.protytype객체에 testMethod() 메서드를 추가하면 이 메서드는 모든 문자열에서 접근 가능하다.
  ```
    String.prototype.testMethod = function () {
      console.log('This is the String.prototype.testMethod()')
    }

    let str = "test is test"
    str.testMethod()

    console.dir(String.prototype)
  ```

### 프로토타입도 자바스크립트 객체다.(PrototypeIsObject.js)
* 함수가 생성될 때, 자신의 prototype 프로퍼티에 연결되는 프로토타입 객체는 디폴트로 constructor 프로퍼티만 가진 객체다.
* 당연히 프로토타입 객체 역시 자바스크립트 객체이므로 일반 객체처럼 동적으로 프로퍼티를 추가/삭제 하는것이 가능하다. 그리고 이렇게 변경된 프로퍼티는 실시간으로 프로토타입 체이닝에 반영된다.

### 프로토타입 메서드와 this 바인딩(PrototypeChainingWithThis.js)
* 프로토타입 객체는 메서드를 가질 수 있다. 만약 프로토타입 메서드 내부에서 this를 사용한다면 이는 어디에 바인딩 될 것인가?
  + 메서드 호출패턴에서의 this는 그 메서드를 호출한 객체에 바인딩 된다는 것을 기억하자.

### 디폴트 프로토타입은 다른 객체로 변경이 가능하다.(ChangePrototype.js)
* 생성자 함수의 프로토타입 객체가 변경되면, 변경된 시점 이후에 생성된 객체들은 변경된 프로토타입 객체로 [[Prototype]] 링크를 연결한다는 점을 기억해야 한다.
* 이에 반해 생성자 함수의 프로토타입이 변경되기 이전에 생성된 객체들은 기존 프로토타입 객체로의 [[Prototype]] 링크를 그대로 유지한다.

### 객체의 프로퍼티 읽기나 메서드를 실행할 때에만 프로토타입 체이닝이 동작한다.(PrototypeChaining.js)
* 객체의 특정 프로퍼티를 읽으려고 할 때, 프로퍼티가 해당 객체에 없는 경우 프로토타입 체이닝이 발생한다.

## 실행 컨텍스트와 클로저

### 실행 컨텍스트 개념(ExecutionContext.js)
* ECMAScript에서는 실행 컨텍스트를 '실행 가능한 코드를 형상화하고 구분하는 추상적인 개념'으로 기술한다. 
* 이를 앞에서 설명한 콜 스택과 연관하여 정의하면, '실행 가능한 자바스크립트 코드 블록이 실행되는 환경'이라고 할 수 있고, 이 컨텍스트 안에 실행에 필요한 여러가지 정보를 담고 있다.
* 여기서 말하는 코드 블록은 대부분의 경우 함수가 된다.
* ECMAScript에서는 실행 컨텍스트가 형성되는 경우를 세가지로 규정하고 있는데 전역 코드, eval() 함수로 실행되는 코드, 함수 안의 코드를 실행할 경우이다.
* 대부분의 프로그래머는 함수로 실행 컨텍스트를 만든다. 그리고 이 코드블록 안에는 변수 및 객체, 실행 가능한 코드가 들어있다.
* 이 코드가 실행되면 실행 컨텍스트가 생성되고, 실행 컨텍스트는 스택 안에 하나씩 차곡차곡 쌓이며, 제일 위에 위치하는 실행 컨텍스트가 현재 실행되고 있는 컨텍스트다.

### 실행 컨텍스트 생성 과정(CreateExecutionContext.js)
1. 활성 객체 생성
  * 실행 컨텍스트가 생성되면 자바스크립트 엔진은 해당 컨텍스트에서 실행에 필요한 여러 가지 정보를 담을 객체를 생성하는데, 이를 활성 객체라고 한다. 
  * 활성객체에 사용하게 될 매개변수나 사용자가 정의한 변수 및 객체를 저장하고, 새로 만들어진 컨텍스트로 접근 가능하게 되어있다.
  * 이는 엔진 내붸서 접근할 수 있다는 뜻으로 사용자는 접근할 수 없다.
2. arguments 객체 생성
3. 스코프 정보 생성
  * 현재 컨텍스트의 유효범위를 나타내는 스코프 정보를 생성한다. 이 스코프 정보는 실행중인 실행 컨텍스트 안에서 연결 리스트와 유사한 형식으로 만들어진다.
  * 현재 컨텍스트에서 특정 변수에 접근해야 할 경우, 이 리스트를 활용한다. 
  * 이 리스트를 '스코프 체인' 이라고 하는데, [[scope]] 프로퍼티로 참조된다.
  * 활성 객체가 스코프 체인의 제일 앞에 추가되며, execute() 함수의 인자나 지역 변수 등에 접근 할 수 있다.
4. 변수 생성
  * 활성 객체와 변수 객체는 같은 객체이다.
  * 변수 객체 안에서 호출된 함수 인자는 각각의 프로퍼티가 만들어지고 그 값이 할당된다. 만약 값이 넘겨지지 않았다면 undefined가 할당된다.
  * CreateExecutionContext.js의 execute() 함수 안에 정의된 변수 a, b와 함수 func()가 생성된다. 
  * 여기서 주의할 점은 이 과정에서는 변수나 내부함수를 단지 메모리에 생성할 뿐, 초기화는 해당 표현식이 실행되기 전까지 이루어지지 않는다는 점이다.
  * 따라서 변수 a, b에는 먼저 undefined가 할당된다. 표현식의 실행은 변수 객체 생성이 다 이루어진 후 시작된다.
5. this 바인딩
  * 마지막 단계에서는 this키워드를 사용하는 값이 할당된다. 여기서 this가 참조하는 객체가 없으면 전역 객체를 참조한다.
6. 코드 실행
  * 1-5에서 하나의 실행 컨텍스트가 생성되고, 변수 객체가 만들어진 후에 코드에 있는 표현식 실행이 이루어진다.
  * 참고로 전역 실행 컨텍스트는 일반적인 실행 컨텍스트와는 약간 다른데, arguments 객체가 없으며, 전역 객체 하나만을 포함하는 스코프 체인이 있다.
  * 전역 실행 컨텍스트는 변수를 초기화하고 이것의 내부 함수는 일반적인 탑 레벨의 함수로 선언된다. 그리고 전역 실행 컨텍스트의 변수 객체가 전역 객체로 사용된다.
  * 즉, 전역 실행 컨텍스트에서는 변수 객체가 곧 전역 객체이다. 따라서 전역전으로 선언된 함수와 변수가 전역 객체의 프로퍼티가 되며 this를 전역객체의 참조로 사용한다.

### 스코프 체인
* 다른언어와 다른게 자바스크립트에서는 함수 내부의 {} 블록은 유효범위가 없다.
* 오직 함수만이 유효 범위의 한 단위가 된다. 
* 이 유효범위를 나타내는 스코프가 [[scope]] 프로퍼티로 각 함수 객체 내에서 연결 리스트 형식으로 관리돠는데 이를 '스코프 체인'이라고 한다.
* 각 함수는 [[scope]] 프로퍼티로 자신이 생성된 실행 컨텍스트의 스코프 체인을 참조한다.
  1. 전역 실행 컨텍스트의 스코프 체인
  2. 함수를 호출한 경우 생성되는 실행 컨텍스트의 스코프 체인(ScopeChainWithFuncCall.js)
* 스코프 체인을 간단히 정리하면
  + 각 함수 객체는 [[scope]] 프로퍼티로 현재 컨텍스트의 스코프 체인을 참조한다.
  + 함수가 실행되면 새로운 실행 컨텍스트가 만들어 지는데, 이 새로운 실행 컨텍스트는 자신이 사용할 스코프 체인을 다름과 같은 방법으로 만든다.
    - 현재 실행되는 함수 객체의 [[scope]] 프로퍼티를 복사하고, 새롭게 생성된 변수 객체를 해당 체인의 제일 앞에 추가한다.
  + 스코프 체인 = 현재 실행 컨텍스트의 변수 객체 + 상위 컨텍스트의 스코프 체인(ScopeChain.js)

## 클로저

### 클로저의 개념(ConceptOfClouser.js)
* 자바스크립트의 함수는 일급 객체로 취급된다. 이는 함수를 다르함수의 인자로 넘길 수 있고, return 함수를 통째로 반환받을 수도 있음을 의미한다. 
* 중요한 건 최종 반환되는 함수가 외부 함수의 지역변수에 접근하고 있다는 것이다.
* 이 지역변수에 접근하려면, 함수가 종료되어 외부 함수의 컨텍스트가 반환되더라도 변수 객체는 반환되는 내부 함수의 스코프체인에 그대로 남아있어야만 접근할 수 있다.
* 이것이 바로 클로저이다. 이미 생명 주기가 끝난 외부 함수의 변수를 참조하는 함수를 클로저라고 한다.
* 예제에서는 outerFunc에 선언된 x를 참조하는 innerFunc가 클로저가 된다. 그리고 클로저로 참조되는 외부 변수 즉, outerFunc의 x와 같은 변수를 자유변수라 한다.
* 클로저라는 이름은 의역하면 '자유 변수에 엮여있는 함수'라는 표현이 맞을 듯 하다.